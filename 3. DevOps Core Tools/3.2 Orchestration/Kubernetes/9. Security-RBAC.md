---
title: "‚Ä¢ Security-RBAC"
parent: "‚Ä¢ Kubernetes"
grand_parent: 3. DevOps Core Tools
nav_order: 9
has_children: true
---

Topics:

RBAC, ServiceAccounts

Network Policies

Secrets management

OPA / Gatekeeper policies

Admission controllers


===================================


# ‚úÖ **Cluster Administration**

---

# **RBAC (Role-Based Access Control)**

## **1. Key Concepts**

| Component              | Scope           | Description                                 |
| ---------------------- | --------------- | ------------------------------------------- |
| **ServiceAccount**     | Namespace level | Used by Pods or automation inside cluster.  |
| **User**               | Cluster level   | External users (admin / devops engineer).   |
| **Role**               | Namespace level | Gives permissions **inside one namespace**. |
| **ClusterRole**        | Cluster level   | Gives permissions across the whole cluster. |
| **RoleBinding**        | Namespace level | Binds a Role to a User/ServiceAccount.      |
| **ClusterRoleBinding** | Cluster level   | Binds ClusterRole to User/ServiceAccount.   |



---

### RBAC Works By

1) Granting verbs (get, list, watch, create, delete, update)

2) On resources (pods, services, deployments, nodes, secrets)

3) Inside a namespace or cluster-wide

### Why RBAC is Needed

1) Fine-grained access control

2) Controls who can deploy / delete / view resources

3) Used in Production for DevOps, Developers, Monitoring, CI/CD tools

---

# **2. ServiceAccount & Role-Based Demo**

### **Delete all manifests**

```bash
sudo kubectl delete -f .
```

### **Check current user**

```bash
kubectl auth whoami
```

Example output:

```
Username: kubernetes-admin
Groups: [kubeadm:cluster-admins system:authenticated]
```

### **Check permissions**

```bash
kubectl auth can-i get pods
kubectl auth can-i get pods -n apache

sudo kubectl apply -f namespace.yml
sudo kubectl auth can-i get pods -n apache

sudo kubectl apply -f deployment.yml
sudo kubectl auth can-i get deployment -n apache
sudo kubectl auth can-i delete deployment -n apache
```

---

# **Create Namespace**

```bash
kubectl apply -f namespace.yml
```

---

# **3. Create Role**

`role.yml`

```yaml
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: apache-manager
  namespace: apache
rules:
  - apiGroups: ["", "apps", "rbac.authorization.k8s.io", "batch"]
    resources: ["pods", "deployments", "services", "hpa"]
    verbs: ["get", "list", "delete", "create", "update"]
```

Apply:

```bash
kubectl apply -f role.yml
kubectl get role -n apache
```

---

# **4. Create ServiceAccount**

`service-account.yml`

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: apache-user
  namespace: apache
```

Apply:

```bash
kubectl apply -f service-account.yml
kubectl get serviceaccount -n apache
```

### **Check permissions BEFORE binding**

```bash
kubectl auth can-i get pods -n apache --as=apache-user
```

Result: **No** (expected)

---

# **5. Create RoleBinding**

`role-binding.yml`

```yaml
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: apache-manager-rolebinding
  namespace: apache
subjects:
- kind: ServiceAccount
  name: apache-user
  namespace: apache
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: apache-manager
```

Apply:

```bash
kubectl apply -f role-binding.yml
kubectl get rolebinding -n apache
```

### **Check permissions AFTER binding**

```bash
kubectl auth can-i get pods -n apache --as=apache-user
kubectl auth can-i list pods -n apache --as=apache-user
```

---

# **Cluster-Level RBAC**

Used for **monitoring**, **dashboard**, **logging**, **cluster automation**.

Components:

* **User** (cluster-wide identity)
* **ClusterRole**
* **ClusterRoleBinding**

---

# **6. Kubernetes Dashboard Setup (Full Practical)**

### **Deploy Dashboard**

```bash
kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml
```

### **Create Admin ServiceAccount + ClusterRoleBinding**

`dashboard-admin-user.yml`

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: admin-user
  namespace: kubernetes-dashboard

---

apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: admin-user-binding
subjects:
- kind: ServiceAccount
  name: admin-user
  namespace: kubernetes-dashboard
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
```

Apply:

```bash
kubectl apply -f dashboard-admin-user.yml
```

### **Start Kubernetes Dashboard**

```bash
kubectl proxy --address='0.0.0.0' --port=8001 --accept-hosts='.*'
```

### **Get Login Token**

```bash
kubectl -n kubernetes-dashboard create token admin-user
```

### **Open Dashboard**

```
http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/
```

If error:

```
Insecure access detected‚Ä¶
```

‚Üí Try locally or use HTTPS.

---

# **7. Custom Resource Definitions (CRDs) ‚Äì Clean Explanation**

CRDs are used to **extend Kubernetes** with your **own APIs**.

### **API Version Concept**

| Resource    | apiVersion                | Meaning            |
| ----------- | ------------------------- | ------------------ |
| Pods        | `v1`                      | Core API group     |
| Deployments | `apps/v1`                 | ‚Äúapps‚Äù API group   |
| Ingress     | `networking.k8s.io/v1`    | Networking Group   |
| CRDs        | `apiextensions.k8s.io/v1` | Define custom APIs |

### **Why CRDs?**

* Create your own Kubernetes objects
* Used by Helm, ArgoCD, Prometheus Operator, Cert-Manager, Istio, Calico, etc.

### **Example CRD**

```yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: backups.mycompany.com
spec:
  group: mycompany.com
  names:
    kind: Backup
    plural: backups
  scope: Namespaced
  versions:
  - name: v1
    served: true
    storage: true
```

### Usage

After creating a CRD, you can create a custom resource:

```yaml
apiVersion: mycompany.com/v1
kind: Backup
metadata:
  name: daily-backup
spec:
  path: /data
  schedule: "0 1 * * *"
```


=============================



‚úî **Pod Security Standards (PSS)**
‚úî **Image Scanning**
‚úî **Network Policies**
‚úî **Secrets Encryption**


---

# ‚úÖ **Security in Kubernetes **

---

# üîê **1. Pod Security Standards (PSS)**

PSS define **security levels** that control what a Pod is allowed to do.

Kubernetes provides **3 Security Levels**:

| Level          | Meaning                     | Use Case                 |
| -------------- | --------------------------- | ------------------------ |
| **Privileged** | Full host access, risky     | Debug, system-level pods |
| **Baseline**   | Minimal restrictions        | Regular apps             |
| **Restricted** | Strong security, zero-trust | Production workloads     |

---

### ‚úî **How PSS Works**

PSS does NOT enforce by itself ‚Äî it must be applied using:

* **Pod Security Admission (PSA)**
* **OPA Gatekeeper** (Optional)
* **Kyverno** (Optional)

PSA modes:

* **enforce** ‚Üí Blocks pod
* **audit** ‚Üí Allows pod but logs violation
* **warn** ‚Üí Allows pod but shows warning

---

### ‚úî **Important PSS Security Controls**

| Control                      | Example                                  |
| ---------------------------- | ---------------------------------------- |
| Run as non-root              | Run container without root user          |
| Prevent privilege escalation | `allowPrivilegeEscalation: false`        |
| Drop capabilities            | `capabilities: drop: ["ALL"]`            |
| Read-only filesystem         | `readOnlyRootFilesystem: true`           |
| No host namespaces           | Cannot use hostPID, hostIPC, hostNetwork |

---

---

# üõ°Ô∏è **2. Image Scanning**

Container images must be scanned for:

* Vulnerabilities (CVEs)
* Malware
* Misconfigurations
* Outdated OS packages
* Hardcoded secrets

---

### ‚úî **Popular Image Scanners**

| Tool              | Type                            |
| ----------------- | ------------------------------- |
| **Trivy**         | Most popular, fast, open source |
| **Anchore**       | Enterprise-grade                |
| **Clair**         | Registry-level scanning         |
| **Aqua Security** | Commercial                      |
| **Snyk**          | DevSecOps scanning              |

---

### ‚úî **When Image Scanning Happens**

1. **Before build** (developer scans Dockerfile)
2. **During CI/CD pipeline** (Jenkins, GitLab CI, GitHub Actions)
3. **During runtime** (Kubernetes admission controller)
4. **Registry scanning** (Docker Hub, ECR, GCR, ACR)

---

### ‚úî **Scanning Checks**

* Vulnerable packages
* Unnecessary ports
* Privileged containers
* Root users in Dockerfile
* Exposed tokens or keys

---

---

# üåê **3. Network Policies**

Used to control **traffic flow** between:

* Pod ‚Üí Pod
* Pod ‚Üí Namespace
* Pod ‚Üí External system

By default:
üëâ **All traffic is allowed** (if no NetworkPolicy is defined)

---

### ‚úî **Network Policy Can Control**

| Type           | Example                            |
| -------------- | ---------------------------------- |
| **Ingress**    | Allow only pods from App namespace |
| **Egress**     | Block outgoing internet traffic    |
| **CIDR-based** | Allow only specific IP ranges      |
| **Port-based** | Allow only port 80/443             |

---

### ‚úî **Requirement**

Network Policies work only if cluster uses a CNI that supports them:

| CNI     | Supports Network Policy? |
| ------- | ------------------------ |
| Calico  | ‚úÖ Yes                    |
| Cilium  | ‚úÖ Yes                    |
| Weave   | ‚úÖ Yes                    |
| Flannel | ‚ùå No                     |

---

### ‚úî **Real Example**

* Block everything except traffic from frontend ‚Üí backend
* Allow only database traffic on port 5432
* Restrict namespaces from talking to each other

---

---

# üîë **4. Secrets Encryption**

By default, Kubernetes Secrets are **Base64 encoded**, NOT encrypted.

To secure Secrets:

### ‚úî **1. Enable Encryption at Rest**

Kube-apiserver encrypts secrets stored in etcd using:

* AES-CBC
* AES-GCM
* Secretbox

---

### ‚úî **2. Use External Secret Managers**

| Tool                    | Description                      |
| ----------------------- | -------------------------------- |
| **AWS Secrets Manager** | For EKS                          |
| **AWS KMS**             | Used with envelope encryption    |
| **HashiCorp Vault**     | Best open-source enterprise tool |
| **Google KMS**          | For GKE                          |
| **Azure Key Vault**     | For AKS                          |

---

### ‚úî **3. Use Sealed Secrets**

Encrypt secrets ‚Üí Commit to Git ‚Üí Decrypt only inside cluster.

Common in GitOps (ArgoCD, Flux).

---

### ‚úî **Secrets Best Practices**

* Never store secrets in Git
* Rotate secrets regularly
* Use environment variables instead of mounting files
* Enable secret encryption in etcd
* Use RBAC to restrict access

