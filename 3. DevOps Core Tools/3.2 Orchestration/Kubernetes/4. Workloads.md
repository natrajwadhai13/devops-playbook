---
title: "â€¢ Workloads"
parent: "â€¢ Kubernetes"
grand_parent: 3. DevOps Core Tools
nav_order: 4
has_children: true
---
Topics Included - Deployments, StatefulSets, DaemonSets, Jobs, CronJobs

Sub-Sections / Deep-Dive Areas -  Rolling updates, Rollbacks, Workload behavior

---


# ğŸ“Œ Kubernetes: StatefulSets 

## ğŸ”· 1. What is a StatefulSet?

A **StatefulSet** is a Kubernetes workload object used to manage **stateful applications**.
It ensures **stable, unique network identity**, **persistent storage**, and **ordered deployment, scaling, and deletion** of Pods.

StatefulSets are used when your application **requires state**, **unique pod names**, and **stable storage**.

**StatefulSet = Deployment for stateful apps with stable identity + persistent storage + ordered management.**

---

## ğŸ”· 2. Why do we need StatefulSets?

Use StatefulSets when applications need:

### âœ… **Persistent storage that doesn't get deleted with the pod**

Each replica gets its own PersistentVolume (PV).

### âœ… **Stable network identity**

Pod names follow a predictable pattern:
`pod-name-0`, `pod-name-1`, `pod-name-2` â€¦

### âœ… **Ordered operations**

* Create in order (0 â†’ 1 â†’ 2â€¦)
* Scale up in order
* Scale down in reverse order
* Delete in order

### âœ… **Applications that cannot function as stateless services**

Examples: Databases, distributed systems, leader-based systems.

---

## ğŸ”· 3. Key Features of StatefulSets

### â­ **1. Stable, Unique Pod Names**

Pods get fixed identities like:

```
mysql-0
mysql-1
mysql-2
```

Even if the pod restarts, it keeps the same name.

---

### â­ **2. Persistent Storage (PVC per Pod)**

Each replica gets its own **PersistentVolumeClaim**, created automatically using `volumeClaimTemplates`.

Storage is not deleted when the pod dies â€” state is preserved.

---

### â­ **3. Ordered Deployment & Scaling**

* Pods start one by one (`0`, then `1`, then `2`).
* Pods terminate in reverse order (`2`, then `1`, then `0`).

This is critical for clusters that require controlled startup/shutdown.

---

### â­ **4. Ordered Rolling Updates**

Kubernetes updates StatefulSet pods sequentially.
Ensures minimum disruption for stateful workloads.

---

### â­ **5. Headless Service for Network Identity**

StatefulSets require a **headless service** (`clusterIP: None`) for stable DNS records.

Example DNS:

```
mysql-0.mysql-service
mysql-1.mysql-service
```

---

## ğŸ”· 4. When to use StatefulSets?

Use for applications that need:

### âœ” Databases

* MySQL
* PostgreSQL
* MongoDB
* Cassandra

### âœ” Distributed Systems

* Kafka
* Zookeeper
* Etcd
* Redis Cluster

### âœ” Applications requiring:

* Stable identity
* Ordered startup
* Persistent storage

---

## ğŸ”· 5. When **NOT** to use StatefulSets?

Do NOT use StatefulSets for:

âŒ Stateless applications
âŒ Apps that don't require unique pod IDs
âŒ Workloads that donâ€™t need persistent disk

Use **Deployments** instead.

---

## ğŸ”· 6. Important Components of StatefulSet

### ğŸ“ **volumeClaimTemplates**

Automatically creates PVCs for each pod.

### ğŸ’¼ **serviceName**

Headless service required for stable DNS.

### ğŸ”¢ **replicas**

Number of pods in the stateful application.

### ğŸ· **pod identity**

Stable pod names assigned by StatefulSet.

---

## ğŸ”· 7. StatefulSet Lifecycle Behavior

| Operation        | Behavior                          |
| ---------------- | --------------------------------- |
| **Creation**     | Pods created one-by-one in order  |
| **Scaling Up**   | New pods come in order (n+1)      |
| **Scaling Down** | Pods removed in reverse order     |
| **Deletion**     | Pod 0 is deleted last             |
| **Restart**      | Pod keeps same name + same volume |

---

## ğŸ”· 8. Common YAML Structure 

A StatefulSet generally includes:

* A headless service
* StatefulSet definition
* Volume claim template

---

====================================================================


# âœ…StatefulSets Practical Notes** 
 

---


## **1. Stateless vs Stateful Applications**

Stateless Applications: Do not store data inside the application; each request is independent.

Stateful Applications: Store data or session state and rely on previous interactions to function correctly.

### **Stateless Apps â†’ Use: Deployment / ReplicaSet / DaemonSet**

* No data dependency
* Every replica is identical
* Example: NGINX, frontend apps

### **Stateful Apps â†’ Use: StatefulSet**

* Each Pod needs **stable network identity**
* Each Pod needs **persistent storage**
* Example: MySQL, MongoDB, Cassandra, Redis

---

# âœ”ï¸ **2. Creating Namespace**

`namespace.yml`

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: mysql
```

Apply:

```bash
kubectl apply -f namespace.yml
```

---

# âœ”ï¸ **3. Headless Service for StatefulSet**

StatefulSet ALWAYS needs a **Headless Service** (ClusterIP=None).

`service.yml`

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql-service
  namespace: mysql
spec:
  clusterIP: None
  selector:
    app: mysql
  ports:
  - name: mysql
    port: 3306
    targetPort: 3306
```

Apply:

```bash
kubectl apply -f service.yml
```

---

# âœ”ï¸ **4. StatefulSet Definition**

`statefulset.yml`

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql-statefulset
  namespace: mysql
spec:
  serviceName: mysql-service
  replicas: 3
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        ports:
        - containerPort: 3306
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: root
        - name: MYSQL_DATABASE
          value: devops
        volumeMounts:
        - name: mysql-data
          mountPath: /var/lib/mysql
  volumeClaimTemplates:
  - metadata:
      name: mysql-data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 1Gi
```

Apply:

```bash
kubectl apply -f statefulset.yml
```

---

# âœ”ï¸ **5. Verification Commands**

### **Check Pods**

```bash
kubectl get pods -n mysql
```

EXPECTED OUTPUT:

```
mysql-statefulset-0
mysql-statefulset-1
mysql-statefulset-2
```

### **Check PVs created automatically**

```bash
kubectl get pv
```

You will see 3 PVs created for 3 replicas.

### **Check Service**

```bash
kubectl get svc -n mysql
```

Output:

```
NAME            TYPE        CLUSTER-IP   PORT(S)
mysql-service   ClusterIP   None         3306/TCP
```

---

# âœ”ï¸ **6. Accessing MySQL In StatefulSet**

Get pod name:

```bash
kubectl get pods -n mysql
```

Exec into first pod:

```bash
kubectl exec -it mysql-statefulset-0 -n mysql -- bash
```

Login MySQL:

```bash
mysql -u root -p
# password: root
```

Check DB:

```sql
SHOW DATABASES;
```

You will see:

```
devops
mysql
sys
performance_schema
information_schema
```

---

# âœ”ï¸ **7. StatefulSet Unique Features (Interview Points)**

### âœ… **1. Stable Network IDs**

Pods are named with **ordinal index**:

```
mysql-statefulset-0
mysql-statefulset-1
mysql-statefulset-2
```

### âœ… **2. Stable Storage**

Deleting pods does NOT delete data.
Example:

```bash
kubectl delete pod mysql-statefulset-0 -n mysql
```

Kubernetes recreates:

```
mysql-statefulset-0  (same name, same PV)
```

### âœ… **3. Ordered Deployment**

Pod creation order:

```
0 â†’ 1 â†’ 2
```

### â— **Deployments do NOT guarantee this**

---

# âœ”ï¸ **8. Deleting StatefulSet Completely**

StatefulSet:

```bash
kubectl delete -f statefulset.yml
```

Headless Service:

```bash
kubectl delete -f service.yml
```

Namespace:

```bash
kubectl delete ns mysql
```

PVs won't auto-delete because `ReclaimPolicy = Retain`.

Delete manually (optional):

```bash
kubectl delete pv <pv-name>
```